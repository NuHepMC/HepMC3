/**
    @page Search Functions

    HepMC3 comes with an optional "Search" library for finding particles
    related to other particles or vertices.  Two main interfaces are defined:
    Relatives, for finding a particular type of relative, and Feature, for
    generating filters based on Features extracted from particles.
    In addition, operator on Filters are also defined.

    ###########################################################################
    @section Relatives Interface
    ###########################################################################

    The Relatives interface is defined within search/include/HepMC3/Relatives.h.
    Classes that obey this interface must provide a set of operator functions
    that take either a GenParticlePtr, ConstGenParticlePtr, GenVertexPtr or
    ConstGenVertexPtr and return a vector of either GenParticlePtr or
    ConstGenParticlePtr.   Note that the versions of the operator functions that
    receive a consted input parameter also return a vector<ConstGenParticlePtr>,
    while the versions that take non-consted input return non-const output.
    This ensures consistency with the rule that consted objects may only return
    pointers to const objects.

    The Relatives base class is abstract, and has a concrete implementation in
    the templated RelativesInterface class.  The RelativesInterface uses type
    erasure so that any class that obeys the defined Relatives interface
    (i.e that has the necessary four operator functions) can be wrapped in the
    RelativesInterface without needing to inherit from Relatives directly.

    For example, if class foo implements the four necessary functions then the
    following will work

    @code{.cpp}
    using FooRelatives = RelativesInterface<Foo>;
    Relatives * relos = new FooRelatives();
    GenParticlePtr someInput;
    vector<GenParticlePtr> foos = (*relos)(someInput);
    @endcode

    The purpose of Relatives is to be able to wrap any viable class in a common
    interface for finding relatives from a particle or vertex.  Examples are
    provided in the form of the _parents and _children classes.  These do not
    inherit from Raltives, but they do implement the necessary functions.
    The _parents and _children class are not intended to be used directly, but
    they are aliased by wrapping in the RelativesInterface:

    @code{.cpp}
    using Parents  = RelativesInterface<_parents>;
    using Children = RelativesInterface<_children>;
    @endcode

    Note as well that the _parents and _children classes use some utility aliases
    to help declare the appropriately consted return type.  For example

    @code{.cpp}
    template<typename GenObject_type>
    GenParticles_type<GenObject_type> operator()(GenObject_type);
    @endcode

    has a return type GenParticles_type that is a vector of GenParticlePtr that
    is consted if GenObject_type is const, but is not consted if GenObject_type
    is not consted.  Note as well the use of enable_if so that a single
    implementation can be used for both the const and non-const version of the
    functions.  For the simple case of _parents the four required funcs could
    have been implemented directly without such templating, but for more
    complicated relatives it avoids duplicated code.

    ###########################################################################
    @section Recursive Relatives
    ###########################################################################

    In addition to the RelativesInterface wrapper, Relatives.h also contains a
    Recursive class that can wrap the underlying relation in recursion.  For
    example, recursion applied to the parents relationship provides all of the
    ancestors, i.e. parents repeatedly applied to the output of parents.  The
    only additional requirement to use the Recursive wrapper is that the
    underlying class must implement a vertex(GenParticlePtr) method that returns
    the appropriate vertex to follow from a given GenParticle.  As long as a
    class has such a method, it is possible to make a recursive version of it

    @code{.cpp}
    using Ancestors = RelativesInterface<Recursive<_parents> >;
    @endcode

    ###########################################################################
    @section Existing Relatives
    ###########################################################################

    The Relatives class contains static implementations of the Parents,
    Children, Ancestors and Descendants relatives, which can be accessed and
    used as follows

    @code{.cpp}

    vector<const Relatives*> relos{&Relatives::PARENTS, &Relatives::ANCESTORS, &Relatives::CHILDREN, &Relatives::DESCENDANTS};
    ConstGenVertexPtr v startPosition;
    // loop over different relationships.
    for(const Relatives* r: relos){
      for(auto p: r(startPosition)){
        // Do something with search result p
      }
    }

    @endcode

*/
