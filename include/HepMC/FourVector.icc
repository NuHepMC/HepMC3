/**
 *  @file FourVector.icc
 *  @brief Implementation of inline functions from \b class FourVector
 *
 */
#include <cmath> // sqrt, fabs
#include <algorithm>

namespace HepMC {

inline const FourVector& FourVector::ZERO_VECTOR() {
    static const FourVector v;
    return v;
}

inline double FourVector::m() const {
    double mm = v4*v4 - v1*v1 - v2*v2 - v3*v3;
    if( mm < 0.0 ) return -sqrt(-mm);
    return sqrt(mm);
}

inline double FourVector::length() const {
    return sqrt( v1*v1 + v2*v2 + v3*v3 + v4*v4 );
}

inline double FourVector::p() const {
  return sqrt( v1*v1 + v2*v2 + v3*v3 );
}

inline double FourVector::pt() const {
  return sqrt( v1*v1 + v2*v2 );
}

inline double FourVector::phi() const {
  return atan2( v2, v1 );
}

inline double FourVector::theta() const {
  return atan2( pt(), v3 );
}

inline double FourVector::eta() const {
  double vp = p();
  return 0.5*log( (vp + v3) / (vp - v3) );
}

inline double FourVector::rap() const {
  return 0.5*log( (v4 + v3) / (v4 - v3) );
}

inline double FourVector::abs_eta() const {
  return std::abs( eta() );
}

inline double FourVector::abs_rap() const {
  return std::abs( rap() );
}

inline double FourVector::delta_phi(const FourVector &v) const {
  double dphi = phi() - v.phi();
  if (dphi != dphi) return dphi;
  while (dphi >=  M_PI) dphi -= 2.*M_PI;
  while (dphi <  -M_PI) dphi += 2.*M_PI;
  return dphi;
}
  
inline double FourVector::delta_theta(const FourVector &v) const {
  return theta() - v.theta();
}

inline double FourVector::delta_eta(const FourVector &v) const {
  return eta() - v.eta();
}

inline double FourVector::delta_rap(const FourVector &v) const {
  return rap() - v.rap();
}

inline double FourVector::delta_r(const FourVector &v) const {
  double dphi = delta_phi(v);
  double deta = delta_eta(v);
  return sqrt( dphi*dphi + deta*deta );
}

inline bool FourVector::is_zero() const {
    return (v1 == 0.0) &&
           (v2 == 0.0) &&
           (v3 == 0.0) &&
           (v4 == 0.0);
}

inline bool FourVector::operator==(const FourVector& rhs) const {
    return (v1 == rhs.v1) &&
           (v2 == rhs.v2) &&
           (v3 == rhs.v3) &&
           (v4 == rhs.v4);
}

inline FourVector FourVector::operator+(const FourVector& rhs) const {
    return FourVector( v1 + rhs.v1,
                       v2 + rhs.v2,
                       v3 + rhs.v3,
                       v4 + rhs.v4 );
}

inline FourVector FourVector::operator-(const FourVector& rhs) const {
    return FourVector( v1 - rhs.v1,
                       v2 - rhs.v2,
                       v3 - rhs.v3,
                       v4 - rhs.v4 );
}

inline FourVector FourVector::operator*(const double rhs) const {
    return FourVector( v1 * rhs,
                       v2 * rhs,
                       v3 * rhs,
                       v4 * rhs );
}

inline FourVector FourVector::operator/(const double rhs) const {
    return FourVector( v1 / rhs,
                       v2 / rhs,
                       v3 / rhs,
                       v4 / rhs );
}

inline void FourVector::operator+=(const FourVector& rhs) {
    v1 += rhs.v1;
    v2 += rhs.v2;
    v3 += rhs.v3;
    v4 += rhs.v4;
}

inline void FourVector::operator-=(const FourVector& rhs) {
    v1 -= rhs.v1;
    v2 -= rhs.v2;
    v3 -= rhs.v3;
    v4 -= rhs.v4;
}

inline void FourVector::operator*=(const double rhs) {
    v1 *= rhs;
    v2 *= rhs;
    v3 *= rhs;
    v4 *= rhs;
}

inline void FourVector::operator/=(const double rhs) {
    v1 /= rhs;
    v2 /= rhs;
    v3 /= rhs;
    v4 /= rhs;
}

/*
/// @brief Compare floating-point numbers
///
/// Bruce Dawson algorithm for comparing floating-point numbers
/// Implementation for 64-bit double precision
/// Updated to remove strict-aliasing warnings
///
/// @see https://randomascii.wordpress.com/category/floating-point/
///
/// @param A first value
/// @param B second value
/// @param maxUlps maximum acceptable deviation in number of units in the last place
///                maxUlps > 0 && maxUlps < 4 * 1024 * 1024
///
inline bool FourVector::AlmostEqual2sComplement(double A, double B, unsigned int maxUlps) {

    // @todo Currently only works on 64-bit machine
  //    BOOST_STATIC_ASSERT( sizeof(double)==8 && sizeof(long long)==8 );
    static const long long MASK = 0x8000000000000000;

    // Not equal if sign is not equal
    bool isNegativeA = (A < 0);
    bool isNegativeB = (B < 0);
    if( isNegativeA != isNegativeB ) return false;

    long long *aInt = reinterpret_cast<long long*>(&A);
    // Make aInt lexicographically ordered as a twos-complement int
    if( *aInt < 0 )
        *aInt = MASK - *aInt;

    // Make bInt lexicographically ordered as a twos-complement int
    long long *bInt = reinterpret_cast<long long*>(&B);
    if( *bInt < 0 )
        *bInt = MASK - *bInt;

    long long intDiff = aInt - bInt;
    if( intDiff < 0 ) intDiff= intDiff*-1;

    if( intDiff <= maxUlps ) return true;

    return false;
}
*/

} // namespace HepMC
